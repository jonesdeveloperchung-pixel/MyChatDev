Refine the proposal below, basically the idea is to benchmark the transfer between PC and Table devices. provide me a cross platforms solution no mater on PC side(Linux, Windows and MacOS) or Tablet device side(Android and iOS).

```

## Overview

|  Media  |  How the test will be run  |  PC side  |  Tablet side  |
|---------|----------------------------|-----------|---------------|
| USB cable (USB‑host / OTG) | *Android* – a small **USB‑host** app that opens an `USBSerialPort` and streams a block of data. <br>*iOS* – no public SPP; use **USB‑mass‑storage** (copy a large file) or **USB‑over‑ADB** (Linux/macOS).  | Python script that opens a **serial port** (`pyserial`), writes data and measures time. | Android Kotlin / Flutter using `flutter_usb_serial`.  |
| Wi‑Fi (LAN / Wi‑Fi Direct) | Both sides open a **TCP socket** on a fixed port and exchange a 10‑100 MiB payload. | Python socket (TCP) – acts as *server* or *client*. | Flutter / Android / iOS using `dart:io` sockets. |
| Bluetooth (Classic SPP) | *Android* – RFCOMM with `flutter_bluetooth_serial`. <br>*iOS* – only BLE or Multipeer; use **MultipeerConnectivity** (peer‑to‑peer). | Python `pybluez` (RFCOMM) server/client. | Android & iOS using `flutter_bluetooth_serial` (Android) + `multipeer_connectivity` (iOS). |

> **Why this combo?**  
> *Python* runs natively on Windows, Linux, macOS – a single script works on all three.  
> *Flutter* produces a single binary that runs on both Android & iOS, sharing the same UI and protocol logic.  
> The protocol is trivial: send a stream of random bytes, record the timestamp at send/receive, and calculate throughput.

---

## 1. The Protocol (in plain words)

```
Client (PC or Tablet)   ─────►  Server (Tablet or PC)

 1. Server waits for a TCP (or Bluetooth RFCOMM) connection on PORT 5001.
 2. Client connects.
 3. Client sends a header:
        - payload_size (uint64 little‑endian)
        - start_timestamp (int64, ms since epoch)
 4. Client sends `payload_size` bytes of random data.
 5. Server receives header, records `server_receive_ts` (ms).
 6. Server writes the payload to a discard buffer (or checks integrity).
 7. Server sends back an ACK header:
        - server_receive_ts (int64, ms)
        - round_trip_time (int64, ms)
 8. Client receives ACK, notes `client_end_ts` (ms).
 9. Both sides compute transfer_rate = payload_size / (client_end_ts - start_timestamp).
```

> **Why timestamps in the payload?**  
> Embedding the client’s start time lets the server compute the exact duration without needing a clock sync.  
> The server’s `server_receive_ts` gives an exact *arrival* instant that the client can compare against.

---

## 2. PC Side – Python Script (`transfer_test.py`)

> **Dependencies** (install once):
> ```bash
> pip install pyserial pybluez
> ```

```python
#!/usr/bin/env python3
"""
transfer_test.py – Run on Windows / Linux / macOS

Usage:
  python transfer_test.py server        # start listening on TCP (port 5001)
  python transfer_test.py client <addr> # connect to <addr> (IP or host) as client
  python transfer_test.py btserver      # start listening over Bluetooth RFCOMM
  python transfer_test.py btclient <bdaddr> # connect to Bluetooth device
"""

import sys
import os
import struct
import time
import socket
import serial
import random
import argparse

HEADER_FMT = "<Qq"  # uint64 payload_size, int64 start_ts_ms
ACK_FMT = "<qq"     # int64 server_recv_ts, int64 rtt_ms

PORT = 5001
CHUNK_SIZE = 65536  # 64 KiB
SERIAL_PORT = "/dev/ttyUSB0"   # or COM3 on Windows
SERIAL_BAUDRATE = 115200

def now_ms():
    return int(time.time() * 1000)

def generate_payload(size):
    """Return a bytes object of length `size` filled with random data."""
    return os.urandom(size)

# ------------------------------------------------------------------
# TCP helpers

def tcp_server():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("", PORT))
        s.listen(1)
        print(f"[TCP] Waiting for a connection on port {PORT} ...")
        conn, addr = s.accept()
        print(f"[TCP] Connected by {addr}")
        run_tcp_conn(conn)

def tcp_client(host):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, PORT))
        print(f"[TCP] Connected to {host}:{PORT}")
        run_tcp_conn(s, is_client=True)

def run_tcp_conn(sock, is_client=False):
    payload_size = 20 * 1024 * 1024  # 20 MiB test
    if is_client:
        start_ts = now_ms()
        header = struct.pack(HEADER_FMT, payload_size, start_ts)
        sock.sendall(header)
        print("[TCP] Header sent, streaming payload...")
        sent = 0
        while sent < payload_size:
            chunk = generate_payload(min(CHUNK_SIZE, payload_size - sent))
            sock.sendall(chunk)
            sent += len(chunk)
        print(f"[TCP] Payload sent ({sent} bytes). Waiting for ACK...")
        ack = sock.recv(struct.calcsize(ACK_FMT))
        srv_ts, rtt = struct.unpack(ACK_FMT, ack)
        end_ts = now_ms()
        rate = payload_size / ((end_ts - start_ts) / 1000)
        print(f"[TCP] Received ACK. RTT={rtt}ms, Rate={rate/1e6:.2f} MiB/s")
    else:
        header = sock.recv(struct.calcsize(HEADER_FMT))
        payload_size, start_ts = struct.unpack(HEADER_FMT, header)
        print(f"[TCP] Header received: size={payload_size} bytes, client start={start_ts}ms")
        received = 0
        while received < payload_size:
            data = sock.recv(min(CHUNK_SIZE, payload_size - received))
            if not data:
                break
            received += len(data)
        srv_recv_ts = now_ms()
        rtt = srv_recv_ts - start_ts
        ack = struct.pack(ACK_FMT, srv_recv_ts, rtt)
        sock.sendall(ack)
        print(f"[TCP] Payload received ({received} bytes). Sent ACK. RTT={rtt}ms")

# ------------------------------------------------------------------
# Serial helpers (USB)

def serial_server():
    ser = serial.Serial(SERIAL_PORT, SERIAL_BAUDRATE, timeout=1)
    print(f"[Serial] Listening on {SERIAL_PORT} at {SERIAL_BAUDRATE}bps")
    while True:
        # Wait for a byte to start a test
        if ser.read(1) == b'S':
            run_serial_conn(ser, is_client=False)

def serial_client():
    ser = serial.Serial(SERIAL_PORT, SERIAL_BAUDRATE, timeout=1)
    print(f"[Serial] Connected to {SERIAL_PORT}")
    ser.write(b'S')
    run_serial_conn(ser, is_client=True)

def run_serial_conn(ser, is_client=False):
    payload_size = 5 * 1024 * 1024  # 5 MiB
    if is_client:
        start_ts = now_ms()
        header = struct.pack(HEADER_FMT, payload_size, start_ts)
        ser.write(header)
        sent = 0
        while sent < payload_size:
            chunk = generate_payload(min(CHUNK_SIZE, payload_size - sent))
            ser.write(chunk)
            sent += len(chunk)
        print(f"[Serial] Payload sent ({sent} bytes). Waiting for ACK...")
        ack = ser.read(struct.calcsize(ACK_FMT))
        srv_ts, rtt = struct.unpack(ACK_FMT, ack)
        end_ts = now_ms()
        rate = payload_size / ((end_ts - start_ts) / 1000)
        print(f"[Serial] Received ACK. RTT={rtt}ms, Rate={rate/1e6:.2f} MiB/s")
    else:
        header = ser.read(struct.calcsize(HEADER_FMT))
        payload_size, start_ts = struct.unpack(HEADER_FMT, header)
        print(f"[Serial] Header received: size={payload_size} bytes")
        received = 0
        while received < payload_size:
            data = ser.read(min(CHUNK_SIZE, payload_size - received))
            if not data:
                break
            received += len(data)
        srv_recv_ts = now_ms()
        rtt = srv_recv_ts - start_ts
        ack = struct.pack(ACK_FMT, srv_recv_ts, rtt)
        ser.write(ack)
        print(f"[Serial] Payload received ({received} bytes). Sent ACK. RTT={rtt}ms")

# ------------------------------------------------------------------
# Bluetooth helpers (RFCOMM)

def bt_server():
    import bluetooth
    server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    server_sock.bind(("", bluetooth.PORT_ANY))
    server_sock.listen(1)
    port = server_sock.getsockname()[1]
    bluetooth.advertise_service(server_sock, "TransferTest",
                                service_id="00001101-0000-1000-8000-00805F9B34FB",
                                service_classes=[bluetooth.SERIAL_PORT_CLASS],
                                profiles=[bluetooth.SERIAL_PORT_PROFILE])
    print(f"[Bluetooth] Waiting for connection on port {port} ...")
    client_sock, client_info = server_sock.accept()
    print(f"[Bluetooth] Accepted connection from {client_info}")
    run_bt_conn(client_sock)

def bt_client(bdaddr):
    import bluetooth
    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    sock.connect((bdaddr, 1))
    print(f"[Bluetooth] Connected to {bdaddr}")
    run_bt_conn(sock, is_client=True)

def run_bt_conn(sock, is_client=False):
    # reuse the same protocol logic as TCP
    if is_client:
        start_ts = now_ms()
        header = struct.pack(HEADER_FMT, 10*1024*1024, start_ts)
        sock.send(header)
        sent = 0
        while sent < 10*1024*1024:
            chunk = generate_payload(min(CHUNK_SIZE, 10*1024*1024 - sent))
            sock.send(chunk)
            sent += len(chunk)
        ack = sock.recv(struct.calcsize(ACK_FMT))
        srv_ts, rtt = struct.unpack(ACK_FMT, ack)
        end_ts = now_ms()
        rate = 10*1024*1024 / ((end_ts - start_ts)/1000)
        print(f"[Bluetooth] RTT={rtt}ms, Rate={rate/1e6:.2f} MiB/s")
    else:
        header = sock.recv(struct.calcsize(HEADER_FMT))
        payload_size, start_ts = struct.unpack(HEADER_FMT, header)
        received = 0
        while received < payload_size:
            data = sock.recv(min(CHUNK_SIZE, payload_size - received))
            if not data: break
            received += len(data)
        srv_ts = now_ms()
        rtt = srv_ts - start_ts
        ack = struct.pack(ACK_FMT, srv_ts, rtt)
        sock.send(ack)

# ------------------------------------------------------------------
# Entry point

def main():
    parser = argparse.ArgumentParser(description="Transfer Rate Tester")
    parser.add_argument("role", choices=["server", "client", "btserver", "btclient"])
    parser.add_argument("arg", nargs="?", default=None)
    args = parser.parse_args()

    if args.role == "server":
        tcp_server()
    elif args.role == "client":
        if not args.arg:
            raise ValueError("Need host IP for client mode")
        tcp_client(args.arg)
    elif args.role == "btserver":
        bt_server()
    elif args.role == "btclient":
        if not args.arg:
            raise ValueError("Need BT address for client mode")
        bt_client(args.arg)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
```

> **What you get**  
> * A single script that works on all OSes.  
> * Three “modes”: TCP over Wi‑Fi, serial over USB, RFCOMM over Bluetooth.  
> * Simple throughput output (MiB/s) and RTT.

---

## 3. Tablet Side – Flutter App (`transfer_test_flutter`)

> **Why Flutter?**  
> One codebase → Android & iOS.  
> Packages exist for: sockets, Bluetooth Classic, MultipeerConnectivity (iOS).  
> UI can be a simple “Start Test” button + log view.

### 3.1. Pubspec.yaml

```yaml
name: transfer_test_flutter
description: Simple transfer rate tester for tablet.

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  flutter:
    sdk: flutter
  # TCP / Wi‑Fi
  dart:io
  # Bluetooth Classic (Android)
  flutter_bluetooth_serial: ^0.2.0
  # iOS Multipeer
  multipeer_connectivity: ^1.0.4
  # UI helpers
  fluttertoast: ^8.1.2
  # Random data generator
  crypto: ^3.0.3

dev_dependencies:
  flutter_test:
    sdk: flutter
```

### 3.2. Main Code (`lib/main.dart`)

```dart
import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_bluetooth_serial/flutter_bluetooth_serial.dart';
import 'package:multipeer_connectivity/multipeer_connectivity.dart';
import 'package:crypto/crypto.dart';

const int TEST_PAYLOAD = 20 * 1024 * 1024; // 20 MiB
const int CHUNK_SIZE = 65536; // 64 KiB
const int TCP_PORT = 5001;

Uint8List randomBytes(int length) {
  final rand = Random.secure();
  final arr = Uint8List(length);
  for (var i = 0; i < length; i++) arr[i] = rand.nextInt(256);
  return arr;
}

Uint8List packHeader(int size, int start) {
  final buffer = BytesBuilder();
  buffer.add(_intToBytes(size));
  buffer.add(_intToBytes(start));
  return buffer.toBytes();
}

Uint8List packAck(int serverTs, int rtt) {
  final buffer = BytesBuilder();
  buffer.add(_intToBytes(serverTs));
  buffer.add(_intToBytes(rtt));
  return buffer.toBytes();
}

int _intToBytes(int val) {
  return ByteData(8)..setInt64(0, val, Endian.big);
}

int _bytesToInt(Uint8List arr) =>
    ByteData.sublistView(arr).getInt64(0, Endian.big);

class TransferTester extends StatefulWidget {
  @override
  _TransferTesterState createState() => _TransferTesterState();
}

class _TransferTesterState extends State<TransferTester> {
  final log = <String>[];
  StreamSubscription? tcpSub;
  StreamSubscription? btSub;
  MultipeerConnectivity? mpc;
  BluetoothConnection? btConn;
  Socket? tcpSock;

  void logMsg(String msg) {
    setState(() => log.add(msg));
    print(msg); // debug console
  }

  // ---------- Wi‑Fi TCP ----------
  Future<void> runTcpClient(String host) async {
    tcpSock = await Socket.connect(host, TCP_PORT);
    final start = DateTime.now().millisecondsSinceEpoch;
    final header = _intToBytes(TEST_PAYLOAD) + _intToBytes(start);
    tcpSock!.add(header);
    logMsg("[TCP] Header sent. Streaming payload...");
    int sent = 0;
    while (sent < TEST_PAYLOAD) {
      final chunk = randomBytes(CHUNK_SIZE);
      tcpSock!.add(chunk);
      sent += chunk.length;
    }
    await tcpSock!.flush();
    logMsg("[TCP] Payload sent. Waiting for ACK...");
    final ack = await tcpSock!.firstWhere((p) => p.length == 16);
    final srvTs = _bytesToInt(ack.sublist(0, 8));
    final rtt = _bytesToInt(ack.sublist(8, 16));
    final end = DateTime.now().millisecondsSinceEpoch;
    final rate = TEST_PAYLOAD / ((end - start) / 1000);
    logMsg("[TCP] RTT=${rtt}ms, Rate=${rate / 1e6} MiB/s");
    tcpSock!.destroy();
  }

  Future<void> runTcpServer() async {
    final server = await ServerSocket.bind(InternetAddress.anyIPv4, TCP_PORT);
    logMsg("[TCP] Server listening on $TCP_PORT");
    server.listen((client) async {
      logMsg("[TCP] Client connected: ${client.remoteAddress}");
      final header = await client.firstWhere((p) => p.length == 16);
      final payloadSize = _bytesToInt(header.sublist(0, 8));
      final clientStart = _bytesToInt(header.sublist(8, 16));
      logMsg("[TCP] Header received: size=$payloadSize");
      int received = 0;
      await for (final data in client) {
        received += data.length;
        if (received >= payloadSize) break;
      }
      final serverTs = DateTime.now().millisecondsSinceEpoch;
      final rtt = serverTs - clientStart;
      final ack = _intToBytes(serverTs) + _intToBytes(rtt);
      client.add(ack);
      logMsg("[TCP] Sent ACK. RTT=${rtt}ms");
    });
  }

  // ---------- Bluetooth Classic ----------
  Future<void> btDiscover() async {
    final devices = await FlutterBluetoothSerial.instance.discoverDevices();
    // simple picker dialog
    final sel = await showDialog<BluetoothDevice>(
      context: context,
      builder: (c) => AlertDialog(
        title: const Text('Pick a device'),
        content: SizedBox(
          height: 250,
          child: ListView(
            children: devices
                .map((d) => ListTile(
                      title: Text(d.name ?? d.address),
                      onTap: () => Navigator.pop(c, d),
                    ))
                .toList(),
          ),
        ),
      ),
    );
    if (sel == null) return;
    final conn = await FlutterBluetoothSerial.instance
        .createConnection(sel.address, timeout: 5000);
    btConn = conn;
    logMsg("[BT] Connected to ${sel.name}");
    // reuse same protocol
    final start = DateTime.now().millisecondsSinceEpoch;
    final header = _intToBytes(TEST_PAYLOAD) + _intToBytes(start);
    await btConn!.output!.write(header);
    int sent = 0;
    while (sent < TEST_PAYLOAD) {
      final chunk = randomBytes(CHUNK_SIZE);
      await btConn!.output!.write(chunk);
      sent += chunk.length;
    }
    final ack = await btConn!.input!.firstWhere((p) => p.length == 16);
    final srvTs = _bytesToInt(ack.sublist(0, 8));
    final rtt = _bytesToInt(ack.sublist(8, 16));
    final end = DateTime.now().millisecondsSinceEpoch;
    final rate = TEST_PAYLOAD / ((end - start) / 1000);
    logMsg("[BT] RTT=${rtt}ms, Rate=${rate / 1e6} MiB/s");
  }

  // ---------- iOS Multipeer ----------
  Future<void> mpcInvite() async {
    mpc = MultipeerConnectivity();
    final myPeer = await mpc!.createPeer();
    final service = MultipeerService(
      serviceName: 'TransferTest',
      serviceType: 'ttest',
      peer: myPeer,
    );
    // advertise & invite
    await mpc!.start(service);
    logMsg("[MPC] Waiting for peers. Please connect from another device.");
  }

  Future<void> runMpcTest() async {
    // after the two devices are paired, call this method
    final socket = await mpc!.acceptConnection();
    // same protocol as above, using socket.read / write
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Transfer Test',
      home: Scaffold(
        appBar: AppBar(title: const Text('Transfer Test')),
        body: ListView.builder(
          itemCount: log.length,
          itemBuilder: (_, i) => ListTile(title: Text(log[i])),
        ),
        floatingActionButton: FloatingActionButton(
          child: const Icon(Icons.play_arrow),
          onPressed: () async {
            // pick a mode
            final mode = await showDialog<String>(
              context: context,
              builder: (c) => SimpleDialog(
                title: const Text('Choose mode'),
                children: [
                  SimpleDialogOption(
                    child: const Text('TCP over Wi‑Fi'),
                    onPressed: () => Navigator.pop(c, 'tcp'),
                  ),
                  SimpleDialogOption(
                    child: const Text('Bluetooth Classic (Android)'),
                    onPressed: () => Navigator.pop(c, 'bt'),
                  ),
                  SimpleDialogOption(
                    child: const Text('Multipeer (iOS)'),
                    onPressed: () => Navigator.pop(c, 'mpc'),
                  ),
                ],
              ),
            );
            if (mode == 'tcp') {
              final host = await showDialog<String>(
                context: context,
                builder: (c) => AlertDialog(
                  title: const Text('Enter Wi‑Fi host IP'),
                  content: TextField(
                    decoration:
                        const InputDecoration(labelText: 'IP address'),
                    onChanged: (v) => Navigator.pop(c, v),
                  ),
                ),
              );
              if (host == null) return;
              runTcpClient(host);
            } else if (mode == 'bt') {
              btDiscover();
            } else if (mode == 'mpc') {
              mpcInvite();
            }
          },
        ),
      ),
    );
  }

  // Implementations of runTcpClient, runBtClient, etc. would mirror the protocol
  // in the Python script, using `socket` and the chosen library.
}
```

> **Key Points**  
> * `dart:io.Socket` → TCP (Wi‑Fi).  
> * `flutter_bluetooth_serial` → classic Bluetooth on Android.  
> * `multipeer_connectivity` → Peer‑to‑Peer on iOS (no need for a BT address).  
> * The same header/ACK protocol is used.  
> * Simple log UI; you can extend it with charts or CSV export.

### 3.3. Permissions

- **Android**  
  - In `android/app/src/main/AndroidManifest.xml` add:

```xml
<uses-permission android:name="android.permission.BLUETOOTH"/>
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/> <!-- For BT discovery -->
```

- **iOS**  
  - In `ios/Runner/Info.plist` add keys:

```xml
<key>NSBluetoothAlwaysUsageDescription</key>
<string>Testing transfer over Bluetooth</string>
<key>NSLocationWhenInUseUsageDescription</key>
<string>Needed for Bluetooth discovery</string>
```

- **Multipeer** requires no special permissions, but you should add `NSBonjourServices`:

```xml
<key>NSBonjourServices</key>
<array>
  <string>_ttest._tcp.</string>
</array>
```

## 4. How the Test Works

| Step | Server (Python) | Client (Flutter/Python) |
|------|-----------------|------------------------|
| 1 | Starts listening on chosen port/BT address. | Connects to server. |
| 2 | Sends header: `payload_size (8 bytes) + start_time (8 bytes)` | Receives header, notes `payload_size`, `start_time`. |
| 3 | Receives `payload_size` bytes of data. | Sends `payload_size` bytes of random data. |
| 4 | Calculates `server_time` (now) and `rtt = server_time - client_start`. | Sends `server_time` + `rtt`. |
| 5 | Client receives ACK, calculates total duration. | Reports `RTT` and `Throughput`. |

> **Throughput**: `payload_size / total_time_in_seconds`.

## 5. Running the Test

1. **Set up a server**:  
   Run the Python script on a machine with the chosen network or BT interface.
2. **Prepare the client**:  
   - For Wi‑Fi: Make sure the client device is on the same Wi‑Fi network and you know the server’s IP.  
   - For Bluetooth: Pair the devices or let the client discover and connect.  
   - For iOS Multipeer: Pair two iOS devices (the app will do the pairing).
3. **Launch the client app** and choose the mode.  
4. **Start the test** – the client will stream the payload, wait for the ACK, and log the results.  
5. **Analyze** – The log shows RTT and throughput. You can export to CSV for further analysis.

---

## 6. Why this is the “best” solution

| Criterion | Python + Flask / Socket | Flutter App (TCP+BT+MPC) |
|-----------|------------------------|--------------------------|
| **Cross‑platform** | Server on PC, client on any OS (Python or Flutter) | Client on Android or iOS, server on same or remote |
| **Ease of Use** | Quick command line, no build steps | One app for both platforms |
| **Network** | Full TCP over Wi‑Fi, reliable | Same |
| **Bluetooth** | Classic Bluetooth (requires pairing) | Classic on Android; iOS uses Multipeer (no BT pairing) |
| **Scalability** | Can run on any machine; simple port config | App can be built for any device |
| **Result Analysis** | Text, logs, CSV | Text, logs, optional GUI |
| **No external infrastructure** | Pure local network | Pure local network (no server) |

With this setup you can:

- **Measure end‑to‑end latency** (RTT).  
- **Measure throughput** (bytes/s).  
- **Identify bottlenecks** (Wi‑Fi vs. Bluetooth vs. Multipeer).  
- **Extend** to real sensor data instead of random payloads.

---

## 7. Next Steps / Enhancements

- **Real Data**: Replace `randomBytes` with actual sensor data or file chunks.  
- **Error handling**: Add retries, timeouts, checksum verification.  
- **UI**: Add progress bars, throughput charts, CSV export.  
- **Multi‑client support**: Allow server to handle several simultaneous clients.  
- **Bluetooth Low Energy**: Use `flutter_blue` for BLE if needed.  
- **Statistical analysis**: Compute mean, median, std dev of RTT/throughput over multiple runs.  

---

### Final Note

This architecture gives you a **single, lightweight framework** to benchmark both **Wi‑Fi** and **Bluetooth** (or iOS peer‑to‑peer) data transfer on a tablet or smartphone.  
You can use the Python script as a quick test server for all platforms, or swap it out for the same logic implemented in Dart if you prefer a fully Flutter‑only solution.
```